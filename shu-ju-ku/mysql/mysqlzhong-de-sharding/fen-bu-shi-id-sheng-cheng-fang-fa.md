# 分布式ID生成方法

---

几乎所有的业务系统，都有生成一个记录标识的需求，例如：

（1）消息标识：message-id

（2）订单标识：order-id

（3）帖子标识：tiezi-id

（4）链路跟踪中的链路标识：trace-id

这个记录标识往往就是数据库中的**唯一主键**，数据库上会建立聚集索引（cluster index），即在物理存储上以这个字段排序。

这个记录标识上的查询，往往又有分页或者排序的业务需求，例如：

（1）拉取最新的一页消息：selectmessage-id/ order by time/ limit 100

（2）拉取最新的一页订单：selectorder-id/ order by time/ limit 100

（3）拉取最新的一页帖子：selecttiezi-id/ order by time/ limit 100

所以往往要有一个time字段，并且在time字段上建立普通索引（non-cluster index）。

我们都知道普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询：

select message-id/ \(order by message-id\)/limit 100

再次强调，能这么做的前提是，message-id的生成基本是**趋势时间递增的**。

这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求：

（1）全局唯一

（2）趋势有序

这也是本文要讨论的核心问题：**如何高效生成趋势有序的全局唯一ID。**

#### **使用数据库的auto\_increment**

使用MySQL数据库自带的 auto\_increment 特性来生成全局唯一递增ID，可以保证唯一性、递增性。

但是有单点风险（主库挂掉就无法提供服务），且性能存在上限（依赖单库的写入速度），难以扩展。

改进方法：（1）增加主库，避免写入单点（2）数据水平切分，保证各主库生成的ID不重复

比如，由1个写库变成3个写库，**每个写库设置不同的auto\_increment初始值，以及相同的增长步长，**库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…。

但这样就丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，我们的目标是趋势递增，不是绝对递增）

此外，数据库的写压力依然很大，每次生成ID都要访问数据库。

#### **单点批量ID生成服务**

数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。

数据库中只存储当前ID的最大值Max，当有应用申请获取ID时，ID生成服务每次批量拉取N个ID，并将Max更新为Max+N。

比如，当前数据库中存储的当前ID为10，应用申请50个ID，则ID生成服务将数据库的当前ID设置为60，然后返回给应用（11, 12, 13, ... ..., 60）这50个ID，应用将这50个ID放在自身的内存中，等用完之后再去ID生成服务索要。

这样，可以保证ID生成的绝对递增有序，且大大的降低了数据库的压力，降低为使用数据库的auto\_increment方案的1/N。

此时，可能会存在空洞问题，比如上面服务申请了50个ID（11, 12, 13, ... ..., 60）之后，还没有用完（只用了11, 12, ..., 55），自身挂掉了，下次再申请，就会从61开始，那么（56, 57, 58, 59, 60）这些ID就永远也用不到了，不过这个问题也不大，而且服务挂掉的几率也比较小。

但是这种方案，仍然存在性能上限，无法进行水平扩展。且业务方应用需要去调用一次ID生成服务，ID生成服务再去操作数据库，涉及多次远程调用，比较耗时。

#### **uuid**

uuid是一种常见的本地生成ID的方法：string ID =GenUUID\(\);

优点：本地生成ID，不需要进行远程调用，时延低；扩展性好，基本可以认为没有性能上限。

缺点：无法保证趋势递增；uuid过长，往往用字符串表示，作为主键建立索引查询效率低，

常见优化方案为“转化为两个uint64整数存储”或者“折半存储”，但折半后不能保证唯一性。所以这种方案很少使用。

#### **取当前毫秒数**

uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？

取当前毫秒数是一种常见方案：uint64 ID = GenTimeMS\(\);

因为是使用毫秒，所以，假如两次生成ID的操作是并发在同一毫秒，就会重复；

改进：

（1）使用微秒，但是假如两次生成ID的操作是并发在同一微秒，也会重复；

（2）使用毫秒，如果同一毫秒内有并发生成ID的请求，使用序列号来区分。这中思路其实类似于下面介绍的snowflake算法。

#### **类snowflake算法**

snowflake是twitter开源的分布式ID生成算法，其使用一个long型（8字节）数字表示ID，这个ID组成如下：![](/assets/屏幕快照 2018-10-08 下午10.04.41.png)

其中，41字节的毫秒数，足够系统使用69年；10字节的机器编码，可以最多扩展到1024台机器；12位的毫秒内序列号，可以支持每毫秒4096的并发（每台机器）。

借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。

举例，假设某公司ID生成器服务的需求如下：

（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W

（2）有2个机房，预计未来5年机房数量小于4个

（3）每个机房机器数小于100台

（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个

（5）…

分析过程如下：

（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年\*365天\*24小时\*3600秒\*1000毫秒=320\*10^9，差不多预留39bit给毫秒数

（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号

（3）5年内机房数小于4个，预留2bit给机房标识

（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识

（5）业务线小于10个，预留4bit给业务线标识

![](http://mmbiz.qpic.cn/mmbiz/YrezxckhYOydMj2Lichnic5csTOdqI2a1mC7utPZR12icoHP8UzEibcVetkkZHxWg3ZNhuItMhiboT2AvBWWKvnDlzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  
这样设计的64bit标识，可以保证：

（1）每个业务线、每个机房、每个机器生成的ID都是不同的

（2）同一个机器，每个毫秒内生成的ID都是不同的

（3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的

（4）将毫秒数放在最高位，保证生成的ID是趋势递增的

snowflake算法解决并发的问题仍然是使用序列号，依赖时间，因此每台服务器分配的ID是虽然是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚，TODO，使用NTP解决？）。如果发生时钟回拨，可能会导致可能生成重复id，可以采取“时钟回退后，拒绝生成ID”的策略回避该问题。

**最后一个容易忽略的问题**：

生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求（但并不总是如此，需要根据具体业务来判断），所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。

在snowflake中，跨毫秒时序列号总是从0开始，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都从0开始，而是从一个0到9的随机数。

内容来源：

[细聊分布式ID生成方法](https://mp.weixin.qq.com/s/0H-GEXlFnM1z-THI8ZGV2Q)

[分布式唯一id：snowflake算法思考](https://juejin.im/post/5a7f9176f265da4e721c73a8)

[twitter-archive**snowflake**/      
](https://github.com/twitter-archive/snowflake/tree/snowflake-2010)

