## HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化

---

HashMap是Map接口基于哈希表\(hash table\)的实现。

在HashMap内部，哈希表的实现是通过数组+单链表/红黑树（JDK1.8）来完成的。

大体实现：HashMap的内部维护一个数组（Node&lt;K,V&gt;\[\] table），该数组的每一个位置存放一个bucket（桶或哈希桶），当添加键值对的时候，首先确定要将该键值对放在哪个桶里（table数组的哪个位置，通过计算key的哈希值，即hashCode\(\)方法），该桶的结构一开始是单链表，但是如果在某一个桶中放入了过多的键值对（hashcode相同，但equal\(\)未false），那么这个桶的结构就会由单链表转换为红黑树。

在JDK8之前，桶结构是链表，JDK8中，桶结构会根据桶中元素个数在链表与红黑树两种数据结构中转换。桶中数量超过8个，就由链表转换为红黑树，桶中数量减少到6，就转换为链表。为什么是8和6呢？红黑树的平均查找时间复杂度为O\(log\(n\)\)，log\(8\)=3，log\(6\)=2.6，链表平均查找时间复杂度O\(n/2\)，8/2 = 4， 6/2 = 3；这种设计是在复杂度和效率上寻求一种平衡。

## HaspMap扩容是怎样扩容的，为什么都是2的N次幂的大小。

---

#### 为什么都是2的N次幂的大小

HashMap有两个参数影响其性能：初始容量和加载因子。默认初始容量是16，加载因子是0.75。

HashMap中计算key的哈希值时，计算方法：

```
(h = key.hashCode()) ^ (h >>> 16)
```

确定键值对应该存放在哪个桶中时，计算方法为：

```
(n - 1) & hash
```

当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。

TODO：为什么？这种位运算的神奇之处在哪？

#### 怎样扩容

扩容时机：

当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。

大体过程：

先将table数组长度变为原来的2倍，然后将table中的键值对重新分配到各个桶中：循环原table，注意的是，循环次数为数组table的长度，而不是HashMap的size（键值对的个数）；在循环体中，对原table中任意一个位置，会判断该位置的结点类型：只有一个、链表、红黑树，然后分类进行重哈希。

如果原table的该位置处的桶结构为链表，则该链表会保留元素顺序：它指的是，假如链表中两个结点a和b，有a.next=b或者a.next.next...=b，那么在重哈希以后，如果a和b仍然在同一链表中，依然会保持a.next=b或者a.next.next...=b的关系；当然只是顺序，next的次数与之前是不同的。

## HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么。

---

## 



