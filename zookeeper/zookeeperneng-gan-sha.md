# zookeeper的应用场景

---

Zookeeper的典型应用场景如下

* 数据发布与订阅（配置中心）

* 负载均衡

* 命名服务（即服务注册与发现）

* 分布式锁

* 分布式队列

* 集群管理与Master选举

* 分布式通知/协调

#### 配置中心

应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。

#### 负载均衡

每台工作服务器在启动时都会去zookeeper的servers节点下注册临时节点，每台客户端在启动时都会去servers节点下取得所有可用的工作服务器列表，并通过一定的负载均衡算法计算得出一台工作服务器，并与之建立网络连接。

#### 服务注册与发现

服务提供者在启动的时候，向ZK上的指定节点/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的注册。

服务消费者启动的时候，订阅/${serviceName}/providers目录下的提供者URL地址， 并向/${serviceName} /consumers目录下写入自己的URL地址。

#### 分布式锁

①建立一个节点，假如名为：lock 。节点类型为持久节点（PERSISTENT）

②每当进程需要访问共享资源时，会调用分布式锁的lock\(\)或tryLock\(\)方法获得锁，这个时候会在第一步创建的lock节点下建立相应的顺序子节点，节点类型为临时顺序节点（EPHEMERAL\_SEQUENTIAL），通过组成特定的名字name+lock+顺序号。

③在建立子节点后，对lock下面的所有以name开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，假如是最小节点，则获得该锁对资源进行访问。

④假如不是该节点，就获得该节点的上一顺序节点，并给该节点是否存在注册监听事件。同时在这里阻塞。等待监听事件的发生，获得锁控制权。

⑤当调用完共享资源后，调用unlock（）方法，关闭zk，进而可以引发监听事件，释放该锁。

这种分布式锁是严格的按照顺序访问的并发锁，即**时序性**。



todo



---
内容来源

[ZooKeeper典型应用场景一览](https://zhuanlan.zhihu.com/p/21625519)
[zookeeper系列（四）实战负载均衡](https://segmentfault.com/a/1190000012185401)



