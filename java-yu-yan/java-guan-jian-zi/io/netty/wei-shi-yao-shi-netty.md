### 传统的BIO编程

网络编程的基本模型都是`Client/Server`模型：即两个进程之间的通信，
其中，
服务端提供位置信息（`IP`和`Port`），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接。

在基于BIO的开发中，
①`ServerSocket`负责绑定`IP`地址，并启动监听端口；
②`Socket`负责发起连接操作；
③连接成功后，双方通过输入和输出流来进行同步阻塞通信

### 基于NIO的非阻塞编程

详见[[NIO基础](/java-yu-yan/java-guan-jian-zi/io/nio/nioji-chu.md)]


### 基于NIO2的AIO编程

`NIO2.0`引入了新的异步通道的概念，并提供了异步文件通道和异步套接字的实现。

异步通道可以通过两种方式来获取操作结果：

* 通过`java.util.concurrent.Future`类来表示异步操作的结果
* 在执行异步操作的时候提供一个`java.io.channels`

`CompletionHandler`接口的实现类作为操作完成的回调。

`NIO2.0` 的异步套接字通道是真正的异步非阻塞IO，对应于`UNIX`网络编程的事件驱动`IO（AIO）`，它不需要通过多路复用器`Selector`对注册的通道进行轮询即可实现异步读写，从而简化了`NIO`的编程模型。

这种编程模型，逻辑更加清晰，更容易编写。


### 为什么要使用NIO编程

如果客户端并发连接数不多，周边对接的网元不多，服务器的负载也不重，那就完全没必要选择NIO做服务端；
如果是相反情况，则要综合考虑选择合适的NIO框架进行开发。


### 为什么要选择Netty

**不选择Java原生NIO编程的原因**
* `NIO`的类库和`API`繁杂，使用麻烦，你需要熟练掌握`Selector、ServerSocketChannel、SocketChannel、ByteBuffer`等
* 需要额外具备其他的额外技能做铺垫，如多线程编程
* 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重试、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，
`NIO`编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。
* `JDK NIO`的`BUG`，例如`epoll bug`，它会导致`Selector`空轮询，最终导致`CPU` 100%。（不确定`JDK 1.8`及更高版本有没有修复）。

**为什么要选择Netty**

`Netty`是业界最流行的`NIO`框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的。`Netty`已经经过了很多商用项目验证，例如`Hadoop`的`RPC`框架以及其他主流`RPC`框架底层都是使用`Netty`作为通信框架。

`Netty`的主要优点：

* `API`使用简单，开发门槛低；

* 功能强大，预置了多种编解码功能，支持多种主流协议；

* 定制能力强，可以通过`ChannelHandler`对通信框架进行灵活的扩展；

* 性能高，通过与其它业界主流的`NIO`框架对比，`Netty`的综合性能最优；

* 成熟、稳定，`Netty`修复了已经发现的所有`JDK NIO BUG`，业务开发人员不需要再为`NIO`的`BUG`而烦恼；

* 社区活跃，版本迭代周期短，发现的`BUG`可以被及时修复，同时，更多的新功能会被加入；

* 经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。

正是因为这些优点，`Netty`逐渐成为`Java NIO`编程的首选框架。