HashMap是基于哈希表实现的Map，其内部结构为**数组+单链表/红黑树。**

当要放入一个元素的时候，首先要解决的问题就是如何将这些元素平均地放置在数组中的各个位置，以减少哈希冲突。

假设数组大小为n（可放置的位置下标为：0,1,2,...,n-1；假设元素的Hash值都是理想的），首先想到的就是采用取余的方法：

```
hash %（n-1）
```

但是这种取余计算对计算机来说是相对比较慢的，解决思路就是使用位运算来替代取余。但是如果想要使用位运算进行取余操作，就有一个前提条件：取余操作中的被除数必须为2的倍数（Power of two），所以HashMap中的数组（Node&lt;K,V&gt;\[\] table）的length会一直保持为2的倍数（即2的m次幂）进行扩容（扩容机制：元素个数大于`table.length * load_factor`，默认值为16\*0.75）。

此时，就可以使用位运算进行取余操作（位运算的效率远远高于`%`运算）：

```
(n - 1) & hash
```





HashMap中计算key的哈希值时，计算方法：

```text
h = key.hashCode()) ^ (h >>> 16)
```

确定键值对应该存放在哪个桶中时，计算方法：

```text
(n - 1) & hash
```

当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。



### 参考

[二次方取余技术在HashMap的应用](http://jingzhongwen.iteye.com/blog/2208680)



